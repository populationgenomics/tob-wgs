---
author: "Centre for Population Genomics"
date: "`r Sys.time()`"
output:
  html_document:
    theme: cosmo
    #css: ../style.css
    toc: true
    code_download: true
    code_folding: show
  rmdformats::material:
    highlight: kate
params:
  title: "Concordance of SNPchip and WGS genotype calls"
title: "`r paste(params$title)`"
---

```{r knitr_opts, include=F}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r load_pkgs}
require(tidyverse)
require(fs)
require(glue)
require(here)
require(reactable)
require(downloadthis)
require(janitor)
require(ggrepel)
require(data.table)
require(DT)
```

```{r funcs}
tobid2chipid <- function(x, id_map) {
  stopifnot(length(x) == 1, c("sample_id", "tob_id") %in% names(id_map))
  chipid <- id_map %>%
    dplyr::filter(tob_id == x)
  if (nrow(chipid) == 1) {
    chipid$sample_id
  } else if (nrow(chipid) == 0) {
    message("No matches! Returning NA.")
    return(NA_character_)
  } else {
    stop("Wait, how did you get more than 1 matches??")
  }
}

run_gvcftools <- function(input, output) {
  idir <- normalizePath(dirname(input))
  ibname <- basename(input)
  dir.create(dirname(output), recursive = TRUE, showWarnings = TRUE)
  odir <- normalizePath(dirname(output))
  obname <- basename(output)

  docker_cmd <- glue(
    "docker run --rm ",
    "-v {idir}:/data/input -v {odir}:/data/output ",
    "quay.io/biocontainers/gvcftools:0.17.0--he941832_3 /bin/bash -c ")
  gvcftools_cmd <- glue("'gzip -dc /data/input/{ibname} | extract_variants | gzip -c > /data/output/{obname}'")

  system(glue("{docker_cmd} {gvcftools_cmd}"))
}

concordance_stats <- function(wgs, snp) {
  gt_match <- snp %>%
    left_join(wgs, by = "chrpos") %>%
    # ignore phasing
    mutate(gt.y = sub("\\|", "/", gt.y),
           gt_equal = gt.x == gt.y)

  nrow_snp <- nrow(snp)
  nrow_wgs <- nrow(wgs)
  n_wgs_in_snp <- sum(wgs[["chrpos"]] %in% snp[["chrpos"]])
  n_snp_in_wgs <- sum(snp[["chrpos"]] %in% wgs[["chrpos"]])
  n_snp_not_in_wgs <- sum(!snp[["chrpos"]] %in% wgs[["chrpos"]])
  n_wgs_not_in_snp <- sum(!wgs[["chrpos"]] %in% snp[["chrpos"]])
  pct_snp_in_wgs <- n_snp_in_wgs / nrow_snp
  pct_wgs_in_snp <- n_wgs_in_snp / nrow_wgs
  n_gt_match <- gt_match %>% filter(gt_equal == TRUE) %>% nrow()
  n_gt_nomatch <- gt_match %>% filter(gt_equal %in% c(FALSE, NA)) %>% nrow()
  pct_gt_match <- n_gt_match / nrow_snp
  pct_gt_nomatch <- n_gt_nomatch / nrow_snp

  list(
    summary = tibble::tibble(
      pct_gt_match = pct_gt_match,
      pct_gt_nomatch = pct_gt_nomatch,
      nrow_snp = nrow_snp,
      nrow_wgs = nrow_wgs,
      n_wgs_in_snp = n_wgs_in_snp,
      n_snp_in_wgs = n_snp_in_wgs,
      n_snp_not_in_wgs = n_snp_not_in_wgs,
      n_wgs_not_in_snp = n_wgs_not_in_snp,
      pct_snp_in_wgs = pct_snp_in_wgs,
      pct_wgs_in_snp = pct_wgs_in_snp,
      n_gt_match = n_gt_match,
      n_gt_nomatch = n_gt_nomatch
    ),
    gt_match = gt_match
  )
}

is_outlier <- function(x, m = 1.5) {
  (x < quantile(x, 0.25) - m * IQR(x)) |
    (x > quantile(x, 0.75) + m * IQR(x))
}

select_snpchip_sample <- function(snpchip, tobid, id_map) {
  snpchip %>%
    select(chrpos, ref, alt, gt = tobid2chipid(tobid, id_map)) %>%
    filter(!gt %in% "0/0") # homref
}

read_wgs_vcf <- function(wgsvcf, tobid) {
  data.table::fread(
    cmd = glue("zgrep -v '^##' {wgsvcf}"), sep = "\t", na.strings = ".",
    drop = c("QUAL", "ID", "FILTER", "INFO", "FORMAT"), data.table = FALSE
  ) %>%
    rename(chr = `#CHROM`, pos = POS, ref = REF, alt = ALT) %>%
    mutate(
      gt = sub("(^.*?):.*", "\\1", .data[[tobid]]),
      chrpos = glue("{chr}_{pos}")) %>%
    select(chrpos, ref, alt, gt) %>%
    tibble::as_tibble()
}

count_gt_per_chrom <- function(d, chrom) {
  # Instead of processing full dataset,
  # split by chromosome (non-parallel).
  d %>%
    filter(chr %in% chrom) %>%
    tidyr::pivot_longer(-chr) %>%
    dplyr::group_by(chr, name) %>%
    dplyr::count(value)
}
```

## Introduction

Here we're exploring genotype concordance between SNPchip and WGS data for the
TOB-WGS project. We have been provided with one multi-sample VCF file containing
genotype calls from the SNPchip data, and several single-sample GVCF files
containing genotype calls from the WGS data.

The basic steps for calculating concordance between the SNPchip and WGS data
are:

1. Convert SNPchip VCF from GRCh37 to hg19, then lift over to GRCh38 using
   [CrossMap](http://crossmap.sourceforge.net/) so that it's the same genome
   assembly as the WGS GVCFs.
2. Extract variant sites from the WGS GVCFs using
   [gvcftools](https://github.com/sequencing/gvcftools). This means that each
   GVCF now becomes a variant site-only WGS VCF (i.e. the large homozygous
   reference blocks are discarded).
3. For a sample with a given TOBID of TOBxxxx, grab the CHR_POS, REF, ALT, and
   SNPID columns (based on SNPID<->TOBID map) from the SNPchip VCF. Do the same
   for the corresponding variant site-only WGS VCF. Also discard the variants
   that are homozygous reference in the SNPchip VCF for TOBxxxx. The WGS VCF
   will have a lot more variants than the SNPchip VCF.
4. Keep WGS rows that are in the SNPchip, based on the CHR_POS column. More than
   99.9% of the SNPchip sites should be there.

## SNPchip VCF file

The SNPchip VCF file was provided in 2021-Mar-17 along with the original
genotype call files. The VCF file was generated using GenomeStudio and
its Plink plugin. The GRCh37 human genome assembly was used.

### Sample names

The TOB sample IDs were originally given to the participants at the time of
blood collection. The genotype platform generated new IDs for the cohort which
are required in the Plink files (Family and Individual IDs (FID and IID)),
and a new key ID was generated by combining `FID_IID` (e.g. `1_1`, `2_2`).

We can map the SNPchip sample names to TOB IDs using the Excel spreadsheet
provided in 2021-Apr-15 by GWCCG.

```{r vars}
chip_vcf_raw <- here("nogit/data/snpchip/raw/onek1k_pre_imputation_genotypes_2021-Mar-17.vcf.gz")
chip_ids_file <- here("nogit/data/snpchip/raw/OneK1K_sample_IDs_2021-Apr-15.xlsx")
```

```{r snpchip_stats}
BCFTOOLS <- glue("~/conda/envs/bioinf/bin/bcftools")

chip_sample_nms <-
  system(glue("{BCFTOOLS} query -l {chip_vcf_raw}"), intern = TRUE) %>%
  dplyr::as_tibble() %>%
  purrr::set_names("sample") %>%
  mutate(chip_vcf_ind = dplyr::row_number(),
         chip_vcf_ind = paste0(chip_vcf_ind, ".")) %>%
  select(chip_vcf_ind, sample)

chip_varcount <-
  system(glue("{BCFTOOLS} stats {chip_vcf_raw} | ",
              "grep -v '^#' | ",
              "grep 'number of records'"), intern = TRUE) %>%
  stringr::str_split("\t") %>%
  purrr::pluck(1, 4)
```

- SNPchip VCF stats:
  - Total of **`r nrow(chip_sample_nms)`** samples.
  - Total of **`r chip_varcount`** variants.

- We note that most of the sample names have different FID and IID from
  column 156 onwards, and the final 5 samples have a `_2` suffix:

```{r snpchip_sample_nms_slice}
chip_sample_nms %>%
  dplyr::slice(c(1:2, 154:157, (n() - 5):n())) %>%
  knitr::kable()
```

- Let's examine the sample IDs provided in the Excel spreadsheet:

```{r snpchip_id2tob_map_explore}
chip_id2tob_raw <-
  chip_ids_file %>%
  readxl::read_excel(skip = 1) %>%
  janitor::clean_names() %>%
  mutate(x1 = person == glue("{index_id_fid}_{internal_id_iid}"),
         tob_id2 = formatC(tob_id, width = 5, format = "d", flag = "0"),
         tob_id2 = glue("TOB-{tob_id2}"),
         x2 = tob_id2 == tob_dark_id,
         tob_id_final = glue("TOB{tob_id}"))

dplyr::glimpse(chip_id2tob_raw)
# is 'person' equal to 'FID_IID'?
chip_id2tob_raw %>% count(x1)
# is 'tob_dark_id' equal to TOB-0XXXX?
chip_id2tob_raw %>% count(x2) # 31 FALSE
# which x2s are FALSE?
chip_id2tob_raw %>%
  filter(!x2) %>%
  select(person, tob_dark_id, tob_id2)
# So TOB-01856 should be TOB-01857, and the rest simply miss a zero prefix.
chip_id2tob_raw %>%
  filter(!x2) %>%
  select(person, tob_dark_id, tob_id2) %>%
  mutate(tob_id3 = sub("-0", "-", tob_id2),
         x3 = tob_id3 == tob_dark_id) %>%
  filter(!x3)

# all samples in excel file correspond to a SNPchip VCF sample
table(chip_id2tob_raw$person %in% chip_sample_nms$sample)
# 51 samples in SNPchip VCF aren't in excel file
table(chip_sample_nms$sample %in% chip_id2tob_raw$person)
chip_sample_nms %>% filter(!sample %in% chip_id2tob_raw$person)
```

- Apart from 51 samples that do not have a TOB ID, now let's just get a clean
  map:

```{r chip_id2tob_prep}
chip_id2tob_clean <-
  chip_sample_nms %>%
  dplyr::left_join(chip_id2tob_raw, by = c("sample" = "person")) %>%
  dplyr::select(chip_vcf_ind, sample_id = sample, tob_id = tob_id_final)

chip_id2tob_clean

# confirm 51 missing values
map_dbl(chip_id2tob_clean, ~sum(is.na(.x)))

# write the TSV locally:
readr::write_tsv(
  x = chip_id2tob_clean,
  file = here("nogit/data/snpchip/processed/sample2tobid_2021-Apr-20.tsv"))
```

### Genotypes

```{r read_vcf}
chip_geno <-
  data.table::fread(
    cmd = glue("zgrep -v '^##' {chip_vcf_raw}"),
    sep = "\t", na.strings = ".",
    drop = c("QUAL", "FILTER", "INFO", "FORMAT"),
    data.table = FALSE) %>%
  dplyr::as_tibble() %>%
  dplyr::rename(chr = `#CHROM`, pos = POS, id = ID, ref = REF, alt = ALT) %>%
  select(-c(pos:alt)) # keep chromosome + genotypes
```

```{r plot_geno1, fig.width=12, fig.height=20}
counts_gt1 <- purrr::map_df(1:22, ~count_gt_per_chrom(chip_geno, .x))

# join with id2tob map
counts_gt1 <-
  counts_gt1 %>%
  dplyr::ungroup() %>%
  dplyr::rename(Sample = name, GT = value, Count = n) %>%
  dplyr::left_join(chip_id2tob_clean, by = c("Sample" = "sample_id"))

theme_set(theme_bw())
# violin per chromosome per gt
p1 <- counts_gt1 %>%
  ggplot(aes(x = "", y = Count)) +
  geom_violin() +
  coord_flip() +
  facet_grid(chr~GT, scales = "free") +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()) +
  ggtitle(glue("SNPchip GT counts per chromosome for {nrow(count(counts_gt1, Sample))} samples."))
# ggsave("gt_count_violin_per_chrom.png", p1, width = 12, height = 20)
p1
```

```{r plot_geno2, fig.width=10, fig.height=12}
# jitter object for proper labels
jitter_pos1 <- ggplot2::position_jitter(width = 0.20, height = 0, seed = 123)

# violin per gt
p2 <- counts_gt1 %>%
  group_by(GT, Sample) %>%
  summarise(Count = sum(Count), .groups = "drop_last") %>%
  dplyr::left_join(chip_id2tob_clean, by = c("Sample" = "sample_id")) %>%
  mutate(
    # too many, so use a large multiplication factor
    outlier = if_else(is_outlier(Count, 6),
                      glue("{tob_id} ({Count})"), NA_character_)) %>%
  ggplot(aes(x = "", y = Count)) +
  geom_violin() +
  geom_point(position = jitter_pos1, shape = 21, colour = "blue") +
  ggrepel::geom_text_repel(position = jitter_pos1, aes(label = outlier),
                           na.rm = TRUE, hjust = -0.3) +
  facet_wrap(~GT, scales = "free") +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()) +
  ggtitle(glue("SNPchip GT counts for {nrow(count(counts_gt1, Sample))} samples."))
# ggsave("gt_count_violin.png", p2, width = 10, height = 12)
p2

rm(p1, p2, jitter_pos1, chip_geno)
```

## Concordance

### SNPchip VCF processing

- First we need to coordinate-sort the SNPchip VCF file, and convert to
  hg19 from GRCh37:

```{bash sort_hg19, eval=FALSE}
INPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/raw/onek1k_pre_imputation_genotypes_2021-Mar-17.vcf.gz"
OUTPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_sorted_hg19.vcf.gz"
BCFTOOLS="${HOME}/conda/envs/bioinf/bin/bcftools"
BGZIP="${HOME}/conda/envs/bioinf/bin/bgzip"
TABIX="${HOME}/conda/envs/bioinf/bin/tabix"

cat <(${BCFTOOLS} view -h ${INPUT_VCF} | sed 's/contig=<ID=/contig=<ID=chr/') \
  <(${BCFTOOLS} view -H ${INPUT_VCF} | sort -k1n,1 -k2n,2 | awk '{ print "chr" $0 }') | \
  ${BGZIP} > ${OUTPUT_VCF}
${TABIX} -p vcf ${OUTPUT_VCF}
```

- Next we can use `CrossMap` to convert the
  hg19 coordinates to GRCh38:

```{bash crossmap, eval=FALSE}
INPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_sorted_hg19.vcf.gz"
OUTPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_GRCh38.vcf"
CHAIN="${HOME}/projects/tob-wgs/nogit/data/snpchip/reference/hg19ToHg38.over.chain.gz"
FASTA38="${HOME}/projects/tob-wgs/nogit/data/snpchip/reference/Homo_sapiens_assembly38.fasta"
CROSSMAP="${HOME}/conda/envs/crossmap/bin/CrossMap.py"

${CROSSMAP} vcf ${CHAIN} ${INPUT_VCF} ${FASTA38} ${OUTPUT_VCF}
```

- Sort and tabix the converted VCF:

```{bash sort_crossmap, eval=FALSE}
INPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_GRCh38.vcf"
OUTPUT_VCF="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_GRCh38_sorted.vcf.gz"
OUTPUT_VCF_CHR1="${HOME}/projects/tob-wgs/nogit/data/snpchip/processed/gt_GRCh38_sorted_chr1.vcf.gz"
BCFTOOLS="${HOME}/conda/envs/bioinf/bin/bcftools"
BGZIP="${HOME}/conda/envs/bioinf/bin/bgzip"
TABIX="${HOME}/conda/envs/bioinf/bin/tabix"

cat <(${BCFTOOLS} view -h ${INPUT_VCF}) \
  <(${BCFTOOLS} view -H ${INPUT_VCF} | sort -k1V,1 -k2n,2) | \
  ${BGZIP} > ${OUTPUT_VCF}
${TABIX} -p vcf ${OUTPUT_VCF}
```

### WGS GVCF processing

- Extract variant sites from the WGS GVCFs using `gvcftools`.
  This means that each GVCF now becomes a variant site-only WGS VCF.

```{r gvcftools, eval=FALSE}
idir <- here("nogit/data/bucket/test/raw")
odir <- here("nogit/data/bucket/test/processed")
run_gvcftools(input = glue("{idir}/TOB1524.g.vcf.gz"),
              output = glue("{odir}/TOB1524_extracted_sites.vcf.gz"))
run_gvcftools(input = glue("{idir}/TOB1532.g.vcf.gz"),
              output = glue("{odir}/TOB1532_extracted_sites.vcf.gz"))
run_gvcftools(input = glue("{idir}/TOB1533.g.vcf.gz"),
              output = glue("{odir}/TOB1533_extracted_sites.vcf.gz"))
```

### Concordance

- Now let's check out the concordance between the converted GRCh38 SNPchip data
  and the variant site-only WGS VCFs:

```{r concordance}
chip_vcf_raw_38 <- here("nogit/data/snpchip/processed/gt_GRCh38_sorted.vcf.gz")
chip_id2tob_clean <-
  here("nogit/data/snpchip/processed/sample2tobid_2021-Apr-20.tsv") %>%
  readr::read_tsv(col_types = cols(.default = "c"))
chip_geno38 <-
  data.table::fread(
    cmd = glue("zgrep -v '^##' {chip_vcf_raw_38}"),
    sep = "\t", na.strings = ".",
    drop = c("QUAL", "FILTER", "INFO", "FORMAT"),
    data.table = FALSE) %>%
  dplyr::as_tibble() %>%
  dplyr::rename(chr = `#CHROM`, pos = POS, id = ID, ref = REF, alt = ALT) %>%
  mutate(chrpos = glue("{chr}_{pos}")) %>%
  select(chrpos, everything())

tob1524_snp <- select_snpchip_sample(chip_geno38, "TOB1524", chip_id2tob_clean)
tob1532_snp <- select_snpchip_sample(chip_geno38, "TOB1532", chip_id2tob_clean)
tob1533_snp <- select_snpchip_sample(chip_geno38, "TOB1533", chip_id2tob_clean)

tob1524_wgs <-
  here("nogit/data/bucket/test/processed/TOB1524_extracted_sites.vcf.gz") %>%
  read_wgs_vcf("TOB1524")
tob1532_wgs <-
  here("nogit/data/bucket/test/processed/TOB1532_extracted_sites.vcf.gz") %>%
  read_wgs_vcf("TOB1532")
tob1533_wgs <-
  here("nogit/data/bucket/test/processed/TOB1533_extracted_sites.vcf.gz") %>%
  read_wgs_vcf("TOB1533")

tob1524_gt_match <- concordance_stats(tob1524_wgs, tob1524_snp)
tob1532_gt_match <- concordance_stats(tob1532_wgs, tob1532_snp)
tob1533_gt_match <- concordance_stats(tob1533_wgs, tob1533_snp)
mixup_1532_vs_1533 <- concordance_stats(tob1532_wgs, tob1533_snp)

tab <-
  purrr::map_df(
    list(
      tob1524 = tob1524_gt_match,
      tob1532 = tob1532_gt_match,
      tob1533 = tob1533_gt_match,
      mixup_32_33 = mixup_1532_vs_1533
    ), "summary",
    .id = "sample"
  )

tab %>%
  mutate(across(where(is.numeric), ~round(.x, 4))) %>%
  DT::datatable(rownames = FALSE, caption = "Concordance Stats",
                filter = list(position = "top", clear = FALSE, plain = TRUE),
                extensions = c("Scroller"),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 300)) %>%
  DT::formatStyle(tab %>%
                    select(where(is_double)) %>%
                    select(!where(is_integer)) %>% names(),
    background = DT::styleColorBar(c(0, 1), "lightgreen"),
    backgroundSize = "90% 90%",
    backgroundRepeat = "no-repeat", backgroundPosition = "center"
  ) %>%
  DT::formatCurrency(tab %>% select(where(is_integer)) %>% names(),
                     currency = "", interval = 3, mark = ",", digits = 0)
```
